import tkinter as tk
from tkinter import scrolledtext, messagebox, ttk
import hashlib
import threading
from datetime import datetime
import logging
import random
import speech_recognition as sr
import pyttsx3
from cryptography.fernet import Fernet
import json
import hmac
import base64
import os
import re
import time
from queue import Queue, Empty
from typing import Callable, Any, Optional, Tuple

# MongoDB imports
from pymongo import MongoClient
from bson.objectid import ObjectId

# Configure logging
logging.basicConfig(
    level=logging.DEBUG,
    filename='medai_pro.log',
    format='%(asctime)s - %(levelname)s - %(message)s',
    filemode='a'
)

class HealthAssistant:
    def __init__(self, root):
        self.root = root
        self.root.title("MedAI Pro - Advanced Health Assistant")
        self.root.geometry("800x600")
        self.root.minsize(600, 400)
        
        # Modern gray color palette
        self.colors = {
            'bg_dark': '#2c3e50',       # Dark blue-gray
            'bg_medium': '#34495e',     # Medium blue-gray
            'bg_light': '#ecf0f1',      # Light gray
            'accent': '#3498db',        # Blue accent
            'accent_dark': '#2980b9',   # Darker blue
            'text_dark': '#2c3e50',     # Dark text
            'text_light': '#ecf0f1',    # Light text
            'text_muted': '#95a5a6',    # Muted text
            'success': '#2ecc71',       # Green
            'warning': '#f39c12',       # Orange
            'error': '#e74c3c',         # Red
            'divider': '#bdc3c7'        # Light divider
        }
        
        # Configure root window
        self.root.configure(bg=self.colors['bg_light'])
        
        # Application state
        self.message_count = 0
        self.max_messages_before_login = 5
        self.logged_in = False
        self.current_user_id = None
        self.current_username = None
        self.chat_display = None
        
        # Initialize MongoDB with robust error handling
        self.initialize_database()
        
        # Initialize components
        self.initialize_components()
        self.create_ui()
        self.show_welcome_message()
        
        # Medical knowledge base
        self.initialize_knowledge_base()
        
        # Sentiment analysis patterns
        self.initialize_sentiment_patterns()

    def initialize_components(self):
        """Initialize all external components"""
        try:
            # Text-to-speech engine
            self.tts_engine = pyttsx3.init()
            voices = self.tts_engine.getProperty('voices')
            if len(voices) > 1:
                self.tts_engine.setProperty('voice', voices[1].id)  # Female voice if available
            self.tts_engine.setProperty('rate', 150)
            
            # Speech recognition
            self.voice_recognizer = sr.Recognizer()
            self.voice_recognizer.energy_threshold = 4000
            
            # Encryption
            self.cipher_suite = Fernet(Fernet.generate_key())
            
        except Exception as e:
            logging.error(f"Component initialization failed: {str(e)}")
            messagebox.showerror("Initialization Error", 
                               "Failed to initialize required components. Check logs for details.")
            self.root.destroy()
    
    def initialize_knowledge_base(self):
        """Initialize medical knowledge base"""
        self.greeting_responses = [
            "Hello! How can I help you today?",
            "Hi there! What can I do for you?",
            "Greetings! I'm here to assist with your health questions.",
            "Hello! Ready to help with any health concerns."
        ]
        
        self.thank_you_responses = [
            "You're welcome! Is there anything else I can help with?",
            "My pleasure! Don't hesitate to ask if you have more questions.",
            "You're very welcome! Feel free to ask me anything else.",
            "Glad I could help! Let me know if you need anything more."
        ]

        self.medical_knowledge = {
            'headache': {
                'description': 'Pain in the head or neck area',
                'suggestions': [
                    'Rest in a quiet, dark room',
                    'Apply a cool compress to your forehead',
                    'Try over-the-counter pain relievers',
                    'Stay hydrated'
                ],
                'medicines': [
                    'Acetaminophen (Tylenol)',
                    'Ibuprofen (Advil, Motrin)',
                    'Aspirin',
                    'Naproxen (Aleve)'
                ],
                'emergency': False
            },
            'fever': {
                'description': 'Elevated body temperature, typically above 100.4¬∞F (38¬∞C)',
                'suggestions': [
                    'Drink plenty of fluids',
                    'Rest',
                    'Use fever-reducing medications',
                    'Take a lukewarm bath'
                ],
                'medicines': [
                    'Acetaminophen (Tylenol)',
                    'Ibuprofen (Advil, Motrin)',
                    'Aspirin (for adults only)'
                ],
                'emergency': False
            },
            'nausea': {
                'description': 'Feeling of sickness with an inclination to vomit',
                'suggestions': [
                    'Sip clear or ice-cold drinks',
                    'Eat light, bland foods',
                    'Avoid fried, greasy, or sweet foods',
                    'Try ginger tea or ginger ale'
                ],
                'medicines': [
                    'Dimenhydrinate (Dramamine)',
                    'Meclizine (Bonine)',
                    'Diphenhydramine (Benadryl)',
                    'Emetrol (for nausea without vomiting)'
                ],
                'emergency': False
            },
            'chest pain': {
                'description': 'Discomfort or pain in the chest area',
                'suggestions': [
                    'Seek immediate medical attention',
                    'Stop any physical activity',
                    'Sit or lie down'
                ],
                'medicines': [
                    'Nitroglycerin (if prescribed for angina)',
                    'Aspirin (if recommended for heart attack)'
                ],
                'emergency': True
            },
            'cough': {
                'description': 'Sudden expulsion of air from the lungs to clear throat or airway',
                'suggestions': [
                    'Stay hydrated with warm liquids',
                    'Use a humidifier',
                    'Try throat lozenges',
                    'Avoid irritants like smoke'
                ],
                'medicines': [
                    'Dextromethorphan (Robitussin DM)',
                    'Guaifenesin (Mucinex)',
                    'Benzonatate (Tessalon Perles)',
                    'Codeine (prescription only)'
                ],
                'emergency': False
            },
            'sore throat': {
                'description': 'Pain, scratchiness or irritation of the throat',
                'suggestions': [
                    'Gargle with warm salt water',
                    'Drink warm liquids',
                    'Use throat lozenges',
                    'Rest your voice'
                ],
                'medicines': [
                    'Acetaminophen or ibuprofen for pain',
                    'Phenylephrine or pseudoephedrine (decongestants)',
                    'Chloraseptic spray',
                    'Cepacol lozenges'
                ],
                'emergency': False
            }
        }

    def initialize_sentiment_patterns(self):
        """Initialize sentiment analysis patterns"""
        self.positive_responses = {
            'good': [
                "I'm happy to hear that you're feeling good! üòä",
                "That's wonderful news! Keep up whatever you're doing. üåü",
                "Great to know you're doing well! Is there anything specific you'd like to discuss?"
            ],
            'fine': [
                "I'm glad you're feeling fine today. üòä",
                "That's good to hear! Let me know if there's anything I can help with."
            ],
            'well': [
                "It's great that you're feeling well! üëç",
                "Wonderful! Maintaining good health is so important."
            ],
            'happy': [
                "Happiness is so important for health! üòÑ",
                "That's fantastic! Positive emotions contribute to overall wellbeing."
            ],
            'better': [
                "I'm so glad you're feeling better! üéâ",
                "That's excellent progress! Whatever you're doing seems to be working."
            ]
        }
        
        self.negative_responses = {
            'bad': [
                "I'm sorry to hear you're feeling bad. üòî",
                "That sounds difficult. Would you like to talk more about what's bothering you?",
                "I'm here to help. Can you tell me more about why you're feeling bad?"
            ],
            'not good': [
                "I'm sorry you're not feeling good. What's troubling you?",
                "That must be hard. Would you like to share more about how you're feeling?"
            ],
            'terrible': [
                "I'm so sorry you're feeling terrible. üòü",
                "That sounds really difficult. Would you like to talk about what's going on?",
                "I'm here to listen. Can you tell me more about what's making you feel terrible?"
            ],
            'awful': [
                "I'm sorry you're feeling awful. That must be really hard. üòî",
                "That sounds very difficult. Would you like to talk more about it?"
            ],
            'sad': [
                "I'm sorry you're feeling sad. üòî",
                "It's okay to feel sad sometimes. Would you like to talk about what's on your mind?",
                "I'm here to listen if you'd like to share what's making you feel sad."
            ],
            'depressed': [
                "I'm sorry you're feeling depressed. That can be really difficult. üòî",
                "Depression can be very hard to deal with. Have you considered talking to a professional about how you're feeling?",
                "I'm here to listen, but please know that professional help is available if you need it."
            ]
        }
        
        self.negation_words = ['not', 'no', 'never', 'none', 'nobody', 'nothing', 
                              'neither', 'nor', 'nowhere', 'hardly', 'scarcely', 
                              'barely', 'doesnt', 'isnt', 'wasnt', 'shouldnt', 
                              'wouldnt', 'couldnt', 'wont', 'cant', 'dont']
        
        self.positive_words = ['good', 'great', 'excellent', 'awesome', 'wonderful',
                              'fantastic', 'amazing', 'happy', 'joyful', 'pleased',
                              'content', 'satisfied', 'delighted', 'ecstatic', 'thrilled',
                              'better', 'well', 'fine', 'okay', 'alright', 'positive']
        
        self.negative_words = ['bad', 'terrible', 'awful', 'horrible', 'sad', 'depressed',
                              'angry', 'upset', 'frustrated', 'annoyed', 'irritated',
                              'miserable', 'unhappy', 'disappointed', 'heartbroken',
                              'anxious', 'stressed', 'worried', 'scared', 'frightened',
                              'fearful', 'pain', 'hurt', 'sick', 'ill', 'unwell','not feeling well']

    def create_ui(self):
        """Create the main user interface with modern gray palette"""
        self.setup_main_frame()
        self.setup_header()
        self.setup_chat_display()
        self.setup_input_area()
        
        # Show database status after UI is created
        self.show_database_status()

    def setup_main_frame(self):
        """Configure the main application frame"""
        # Create main container with subtle shadow effect
        self.main_frame = tk.Frame(self.root, bg=self.colors['bg_light'], padx=10, pady=10)
        self.main_frame.pack(fill='both', expand=True)
        
        # Add a subtle shadow effect with nested frames
        shadow_frame = tk.Frame(self.main_frame, bg=self.colors['text_muted'], padx=1, pady=1)
        shadow_frame.pack(fill='both', expand=True)
        
        # Content frame with rounded corners (simulated with padding)
        self.content_frame = tk.Frame(shadow_frame, bg=self.colors['bg_light'], padx=2, pady=2)
        self.content_frame.pack(fill='both', expand=True)

    def setup_header(self):
        """Create the application header"""
        header_frame = tk.Frame(self.content_frame, bg=self.colors['bg_dark'], height=70)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        # Application logo/title with modern font
        title_frame = tk.Frame(header_frame, bg=self.colors['bg_dark'])
        title_frame.pack(side='left', padx=20)
        
        tk.Label(
            title_frame,
            text="MedAI",
            font=('Arial', 22, 'bold'),
            bg=self.colors['bg_dark'],
            fg=self.colors['accent']
        ).pack(side='left')
        
        tk.Label(
            title_frame,
            text="Pro",
            font=('Arial', 22),
            bg=self.colors['bg_dark'],
            fg=self.colors['text_light']
        ).pack(side='left')
        
        # Subtitle
        tk.Label(
            title_frame,
            text="Advanced Health Assistant",
            font=('Arial', 10),
            bg=self.colors['bg_dark'],
            fg=self.colors['text_muted']
        ).pack(side='left', padx=(10, 0))
        
        # User status area
        self.user_status_frame = tk.Frame(header_frame, bg=self.colors['bg_dark'])
        self.user_status_frame.pack(side='right', padx=20)
        
        # Login button
        self.login_button = tk.Button(
            self.user_status_frame,
            text="Login",
            command=self.show_auth_dialog,
            bg=self.colors['accent'],
            fg=self.colors['text_light'],
            font=('Arial', 11),
            padx=15,
            relief=tk.FLAT,
            activebackground=self.colors['accent_dark'],
            activeforeground=self.colors['text_light']
        )
        self.login_button.pack(side='left', padx=(0, 5))
        
        # Signup button (initially visible)
        self.signup_button = tk.Button(
            self.user_status_frame,
            text="Sign Up",
            command=lambda: self.show_auth_dialog(mode='signup'),
            bg=self.colors['success'],
            fg=self.colors['text_light'],
            font=('Arial', 11),
            padx=15,
            relief=tk.FLAT,
            activebackground='#27ae60',  # Darker green on hover
            activeforeground=self.colors['text_light']
        )
        self.signup_button.pack(side='left')
        
        # User label (initially showing "Guest")
        self.user_label = tk.Label(
            self.user_status_frame,
            text="Guest",
            font=('Arial', 11),
            bg=self.colors['bg_dark'],
            fg=self.colors['text_muted']
        )
        self.user_label.pack(side='left', padx=10)

    def setup_chat_display(self):
        """Configure the chat display area"""
        # Chat container with subtle border
        chat_container = tk.Frame(
            self.content_frame,
            bg=self.colors['bg_light'],
            padx=2,
            pady=2
        )
        chat_container.pack(fill='both', expand=True, pady=1)
        
        # Chat display with custom styling
        self.chat_display = scrolledtext.ScrolledText(
            chat_container,
            wrap=tk.WORD,
            state='disabled',
            font=('Arial', 11),
            bg='white',
            fg=self.colors['text_dark'],
            padx=15,
            pady=15,
            borderwidth=0,
            insertbackground=self.colors['accent']
        )
        self.chat_display.pack(fill='both', expand=True)
        
        # Configure message styling
        self.configure_message_tags()

    def configure_message_tags(self):
        """Set up text tags for different message types"""
        self.chat_display.tag_config('assistant', foreground=self.colors['text_dark'], lmargin1=20, rmargin=20)
        self.chat_display.tag_config('user', foreground=self.colors['accent'], lmargin1=20, rmargin=20, justify='right')
        self.chat_display.tag_config('system', foreground=self.colors['text_muted'], font=('Arial', 9))
        self.chat_display.tag_config('emergency', foreground=self.colors['error'], font=('Arial', 11, 'bold'))
        self.chat_display.tag_config('warning', foreground=self.colors['warning'])
        self.chat_display.tag_config('timestamp', foreground=self.colors['text_muted'], font=('Arial', 8))
        self.chat_display.tag_config('timestamp_right', foreground=self.colors['text_muted'], font=('Arial', 8), justify='right')
        self.chat_display.tag_config('divider', foreground=self.colors['divider'])
        self.chat_display.tag_config('empathy', foreground='#9b59b6', font=('Arial', 11, 'italic'))

    def setup_input_area(self):
        """Create the message input area"""
        # Input container with subtle shadow
        input_container = tk.Frame(self.content_frame, bg=self.colors['bg_medium'], padx=2, pady=2)
        input_container.pack(fill='x', pady=(1, 0))
        
        input_frame = tk.Frame(input_container, bg=self.colors['bg_medium'], padx=10, pady=10)
        input_frame.pack(fill='x')
        
        # Message entry with rounded appearance
        entry_frame = tk.Frame(input_frame, bg='white', padx=2, pady=2, bd=0, highlightthickness=1, highlightbackground=self.colors['divider'])
        entry_frame.pack(side='left', fill='x', expand=True, padx=(0, 10))
        
        self.user_input = tk.Entry(
            entry_frame,
            font=('Arial', 11),
            bg='white',
            fg=self.colors['text_dark'],
            insertbackground=self.colors['accent'],
            relief=tk.FLAT,
            bd=8  # Internal padding
        )
        self.user_input.pack(fill='x', expand=True)
        self.user_input.bind('<Return>', self.process_input)
        
        # Button frame for consistent spacing
        button_frame = tk.Frame(input_frame, bg=self.colors['bg_medium'])
        button_frame.pack(side='right')
        
        # Voice input button
        self.voice_button = tk.Button(
            button_frame,
            text="üé§",
            command=self.start_voice_input,
            bg=self.colors['bg_dark'],
            fg=self.colors['text_light'],
            width=3,
            font=('Arial', 11),
            relief=tk.FLAT,
            activebackground=self.colors['bg_medium'],
            activeforeground=self.colors['text_light']
        )
        self.voice_button.pack(side='left', padx=5)
        
        # Send button
        tk.Button(
            button_frame,
            text="Send",
            command=self.process_input,
            bg=self.colors['accent'],
            fg=self.colors['text_light'],
            font=('Arial', 11),
            padx=15,
            relief=tk.FLAT,
            activebackground=self.colors['accent_dark'],
            activeforeground=self.colors['text_light']
        ).pack(side='left')

    def load_conversation_history(self):
        """Load and display the full conversation history from MongoDB."""
        try:
            if not self.logged_in or not self.current_user_id:
                self.add_message("System", "No messages found in conversation history.", tag='system', speak=False)
                return
            messages = list(self.conversations_col.find(
                {"user_id": self.current_user_id}
            ).sort("timestamp", 1))  # 1 for oldest to newest
            if not messages:
                self.add_message("System", "No messages found in conversation history.", tag='system', speak=False)
            else:
                for msg in messages:
                    time_str = msg["timestamp"].strftime("%H:%M") if isinstance(msg["timestamp"], datetime) else str(msg["timestamp"])
                    sender = msg["sender"].capitalize()
                    message = msg["message"]
                    self.chat_display.config(state='normal')
                    self.chat_display.insert(tk.END, f"[{time_str}] {sender}: {message}\n", 'assistant' if sender != 'You' else 'user')
                    self.chat_display.config(state='disabled')
                    self.chat_display.see(tk.END)
        except Exception as e:
            logging.error(f"Failed to load conversation history: {str(e)}")
            self.add_message("System", "Error loading conversation history.", tag='warning', speak=False)

    def show_welcome_message(self):
        """Display welcome message when app starts"""
        welcome_message = (
            "Welcome to MedAI Pro! üëã\n\n"
            "I'm your personal health assistant, designed to provide general health information "
            "and guidance. You can ask me about symptoms, medications, or general health topics.\n\n"
            "Please note that I'm not a replacement for professional medical advice. "
            "Always consult with a healthcare provider for serious concerns."
        )
        
        self.add_message("Health Assistant", welcome_message)
        
        # Show database status
        if hasattr(self, 'mongo_client') and self.mongo_client:
            self.add_message(
                "System", 
                "Database connected successfully", 
                tag='system', 
                speak=False
            )    
    def add_message(self, sender, message, tag=None, speak=True):
        """Add a message to the chat display with proper formatting"""
        # Check if chat_display is initialized
        if self.chat_display is None:
            logging.info(f"Message queued (chat not ready): {sender}: {message}")
            return
        
        self.chat_display.config(state='normal')
        
        # Add timestamp - position depends on sender
        timestamp = datetime.now().strftime("%H:%M")
        
        # Determine message styling
        if tag:
            message_tag = tag
        elif sender == "You":
            message_tag = 'user'
            # Add some spacing before user messages
            self.chat_display.insert(tk.END, "\n", 'user')
        elif sender == "System":
            message_tag = 'system'
        else:
            message_tag = 'assistant'
        
        # Format message differently based on sender
        if sender == "You":
            # For user messages, put timestamp on the right
            self.chat_display.insert(tk.END, f"{sender}: ", message_tag)
            self.chat_display.insert(tk.END, f"{message} ", message_tag)
            self.chat_display.insert(tk.END, f"[{timestamp}]", 'timestamp_right')
            self.chat_display.insert(tk.END, "\n", message_tag)
        elif sender == "System":
            # For system messages
            self.chat_display.insert(tk.END, f"[{timestamp}] ", 'timestamp')
            self.chat_display.insert(tk.END, f"‚ÑπÔ∏è {sender}: ", message_tag)
            self.chat_display.insert(tk.END, f"{message}\n", message_tag)
        elif sender == "Health Assistant":
            # For assistant messages
            self.chat_display.insert(tk.END, f"[{timestamp}] ", 'timestamp')
            self.chat_display.insert(tk.END, f"ü§ñ {sender}: ", message_tag)
            self.chat_display.insert(tk.END, f"{message}\n", message_tag)
        else:
            # For other messages
            self.chat_display.insert(tk.END, f"[{timestamp}] ", 'timestamp')
            self.chat_display.insert(tk.END, f"{sender}: ", message_tag)
            self.chat_display.insert(tk.END, f"{message}\n", message_tag)
        
        # Add divider
        self.chat_display.insert(tk.END, "-"*50 + "\n", 'divider')
        
        self.chat_display.config(state='disabled')
        self.chat_display.see(tk.END)
        
        # Speak assistant messages aloud
        if speak and sender != "You" and sender != "System":
            threading.Thread(
                target=self.speak,
                args=(message,),
                daemon=True
            ).start()
        
        # Save to database if logged in and it's a user or assistant message
        if self.logged_in and sender in ("You", "Health Assistant"):
            self.save_message_to_db(sender, message)

    def save_message_to_db(self, sender, message):
        """Save conversation to MongoDB"""
        try:
            if not self.logged_in or not self.current_user_id:
                logging.debug("Not saving message - no logged in user")
                return
            self.conversations_col.insert_one({
                "user_id": self.current_user_id,
                "message": message,
                "sender": sender,
                "timestamp": datetime.now()
            })
            logging.debug(f"Message saved successfully: {sender}: {message[:50]}...")
        except Exception as e:
            error_msg = f"Unexpected error saving message: {str(e)}"
            logging.error(error_msg)
            print(error_msg)
            self.add_message(
                "System",
                "Failed to save conversation history to database",
                tag='warning',
                speak=False
            )

    def process_input(self, event=None):
        """Process user input from text or voice"""
        user_text = self.user_input.get().strip()
        if not user_text:
            return
        
        # Check message limit for guests
        if not self.logged_in and self.message_count >= self.max_messages_before_login:
            self.add_message(
                "System",
                f"Guest message limit reached. Please login to continue.",
                tag='warning'
            )
            self.show_auth_dialog()
            return
        
        self.user_input.delete(0, tk.END)
        self.add_message("You", user_text)
        self.message_count += 1
        
        # Process in background to keep UI responsive
        threading.Thread(
            target=self.generate_response,
            args=(user_text,),
            daemon=True
        ).start()
    
    def analyze_sentiment(self, text):
        """Analyze text for positive or negative sentiment"""
        lower_text = text.lower()
        # Check for common negative phrases first
        negative_phrases = ['not feeling well', 'not doing well', 'not good', 'not okay', 'not well', 'not fine', 'not happy', 'not great','not feeling good','not fine','not happy','feeling unwell','feeling bad']
        for phrase in negative_phrases:
            if phrase in lower_text:
                return {
                    'sentiment': 'negative',
                    'word': phrase,
                    'is_negated': False
                }
        # Check for negative words
        for negative_word in self.negative_words:
            if negative_word in lower_text:
                for negation in self.negation_words:
                    if f"{negation} {negative_word}" in lower_text:
                        return {
                            'sentiment': 'positive',
                            'word': f"{negation} {negative_word}",
                            'is_negated': True
                        }
                return {
                    'sentiment': 'negative',
                    'word': negative_word,
                    'is_negated': False
                }
        # Check for positive words
        for positive_word in self.positive_words:
            if positive_word in lower_text:
                for negation in self.negation_words:
                    if f"{negation} {positive_word}" in lower_text:
                        return {
                            'sentiment': 'negative',
                            'word': f"{negation} {positive_word}",
                            'is_negated': True
                        }
                return {
                    'sentiment': 'positive',
                    'word': positive_word,
                    'is_negated': False
                }
        # Default to neutral if no sentiment detected
        return {
            'sentiment': 'neutral',
            'word': None,
            'is_negated': False
        }
    
    def generate_response(self, user_input):
        """Generate appropriate response to user input"""
        try:
            lower_input = user_input.lower()
            
            # Handle empty input
            if not user_input.strip():
                return "I didn't receive any input. Could you please repeat your question?"
                
            # Handle greetings
            if any(greeting in lower_input for greeting in ['hi', 'hello', 'hey']):
                response = random.choice(self.greeting_responses)
                self.add_message("Health Assistant", response)
                return
                
            # Handle thanks
            if any(thanks in lower_input for thanks in ['thank', 'thanks', 'appreciate']):
                response = random.choice(self.thank_you_responses)
                self.add_message("Health Assistant", response)
                return
            
            # Handle capability questions
            if 'what can you do' in lower_input:
                self.add_message("Health Assistant", self.describe_capabilities())
                return
                
            # Handle help requests
            if 'help' in lower_input:
                self.add_message("Health Assistant", self.provide_help())
                return
            
            # First analyze sentiment
            sentiment = self.analyze_sentiment(user_input)
            
            # Handle positive sentiment
            if sentiment['sentiment'] == 'positive' and not sentiment['is_negated']:
                if sentiment['word'] in self.positive_responses:
                    response = random.choice(self.positive_responses[sentiment['word']])
                    self.add_message("Health Assistant", response)
                    return
                else:
                    response = random.choice([
                        "That's great to hear! üòä",
                        "I'm glad you're feeling positive!",
                        "Wonderful! How can I help you today?"
                    ])
                    self.add_message("Health Assistant", response)
                    return
            
            # Handle negative sentiment
            if sentiment['sentiment'] == 'negative' or (sentiment['sentiment'] == 'positive' and sentiment['is_negated']):
                if sentiment['word'] in self.negative_responses:
                    response = random.choice(self.negative_responses[sentiment['word']])
                    self.add_message("Health Assistant", response, tag='empathy')
                    return
                else:
                    response = random.choice([
                        "I'm sorry to hear that. üòî Would you like to talk about what's bothering you?",
                        "That sounds difficult. I'm here to listen if you'd like to share more.",
                        "I'm sorry you're feeling this way. Can you tell me more about what's going on?"
                    ])
                    self.add_message("Health Assistant", response, tag='empathy')
                    return
            
            # If no sentiment detected, proceed with regular analysis
            analysis = self.analyze_input(user_input.lower())
            
            # Generate response based on analysis
            try:
                if analysis['is_emergency']:
                    response = self.handle_emergency(analysis)
                elif analysis.get('intent') == 'medication_advice':
                    response = self.handle_medication_advice(analysis)
                elif analysis['intent'] == 'symptom':
                    response = self.handle_symptom(analysis)
                elif analysis['intent'] == 'medication':
                    response = self.handle_medication(analysis)
                elif analysis['intent'] == 'appointment':
                    response = self.handle_appointment()
                elif analysis['intent'] == 'general_health':
                    response = self.handle_general_health(analysis)
                elif analysis['intent'] == 'nutrition':
                    response = self.handle_nutrition(analysis)
                elif analysis['intent'] == 'exercise':
                    response = self.handle_exercise(analysis)
                elif analysis['intent'] == 'mental_health':
                    response = self.handle_mental_health(analysis)
                else:
                    response = self.handle_general_query(user_input)
                
                self.add_message("Health Assistant", response)
                
            except Exception as e:
                logging.error(f"Error generating specific response: {str(e)}")
                self.add_message(
                    "Health Assistant",
                    "I'm having trouble understanding your request. Could you please rephrase or provide more details?",
                    tag='warning'
                )
                
        except Exception as e:
            logging.error(f"Response generation failed: {str(e)}")
            self.add_message(
                "Health Assistant",
                "I encountered an unexpected error. Please try again with a different request.",
                tag='warning'
            )
    
    def describe_capabilities(self):
        """Describe what the assistant can do"""
        return (
            "I can help with:\n"
            "- Symptom analysis and basic advice\n"
            "- Medication information\n"
            "- General health questions\n"
            "- Nutrition and exercise guidance\n"
            "- Mental health information\n"
            "- Appointment booking guidance\n\n"
            "Try asking about specific symptoms or health topics!"
        )

        def provide_help(self):
            """Provide help instructions"""
        return (
            "Here's how to use me effectively:\n"
            "1. Describe symptoms clearly (e.g., 'I have a headache')\n"
            "2. Ask about medications (e.g., 'What is ibuprofen for?')\n"
            "3. Request general health information\n"
            "4. Use the microphone button for voice input\n\n"
            "For emergencies, say words like 'emergency' or 'help' immediately."
        )

    def analyze_input(self, text):
        lower_text = text.lower()
        
        # Medication advice patterns for robust matching
        medication_advice_patterns = [
            r'shall i take (.*) for (.*)',
            r'can i take (.*) for (.*)',
            r'is (.*) good for (.*)',
            r'should i take (.*) for (.*)',
            r'can (.*) be taken for (.*)',
            r'is it safe to take (.*) for (.*)',
            r'would (.*) help with (.*)',
            r'can (.*) treat (.*)',
            r'does (.*) work for (.*)',
            r'will (.*) help (.*)'
        ]
        
        for pattern in medication_advice_patterns:
            match = re.search(pattern, lower_text)
            if match:
                medication = match.group(1).strip()
                symptom = match.group(2).strip()
                return {
                    'intent': 'medication_advice',
                    'medication': medication,
                    'symptom': symptom,
                    'is_emergency': False
                }
        
        # Check for emergency keywords
        emergency_keywords = [
            'emergency', 'heart attack', 'stroke', 'chest pain', 'severe pain',
            'can\'t breathe', 'difficulty breathing', 'choking', 'unconscious',
            'bleeding heavily', 'broken bone', 'burn', 'poison', 'suicide',
            'help me', '911', 'call ambulance', 'urgent', 'life threatening'
        ]
        
        if any(keyword in lower_text for keyword in emergency_keywords):
            return {
                'intent': 'emergency',
                'is_emergency': True
            }
        
        # Check for symptom-related queries
        symptom_keywords = [
            'headache', 'fever', 'cough', 'sore throat', 'nausea', 'vomiting',
            'diarrhea', 'constipation', 'rash', 'itch', 'pain', 'ache',
            'dizziness', 'fatigue', 'weakness', 'swelling', 'bleeding',
            'bruise', 'injury', 'stomach ache', 'back pain', 'joint pain',
            'allergy', 'allergic reaction', 'sneeze', 'runny nose',
            'congestion', 'shortness of breath', 'wheeze'
        ]
        
        found_symptoms = [symptom for symptom in symptom_keywords if symptom in lower_text]
        if found_symptoms:
            return {
                'intent': 'symptom',
                'symptoms': found_symptoms,
                'is_emergency': False
            }
        
        # Check for medication queries
        medication_keywords = [
            'medicine', 'medication', 'pill', 'drug', 'ibuprofen', 'acetaminophen',
            'aspirin', 'tylenol', 'advil', 'aleve', 'benadryl', 'pepto',
            'antacid', 'antibiotic', 'prescription', 'dose', 'dosage',
            'side effect', 'interaction'
        ]
        
        if any(keyword in lower_text for keyword in medication_keywords):
            return {
                'intent': 'medication',
                'is_emergency': False
            }
        
        # Check for appointment requests
        appointment_keywords = [
            'appointment', 'schedule', 'doctor', 'physician', 'clinic',
            'hospital', 'see a doctor', 'make an appointment', 'book',
            'availability', 'when can i see'
        ]
        
        if any(keyword in lower_text for keyword in appointment_keywords):
            return {
                'intent': 'appointment',
                'is_emergency': False
            }
        
        # Check for general health questions
        general_health_keywords = [
            'healthy', 'health', 'wellness', 'prevention', 'vaccine',
            'immunization', 'checkup', 'physical', 'exam', 'screening',
            'test', 'results', 'diagnosis', 'condition', 'disease',
            'illness', 'infection'
        ]
        
        if any(keyword in lower_text for keyword in general_health_keywords):
            return {
                'intent': 'general_health',
                'is_emergency': False
            }
        
        # Check for nutrition questions
        nutrition_keywords = [
            'diet', 'nutrition', 'food', 'eat', 'drink', 'vitamin',
            'mineral', 'supplement', 'calorie', 'protein', 'carb',
            'fat', 'fiber', 'water', 'hydrate', 'dehydrate',
            'healthy eating', 'meal plan', 'weight loss', 'weight gain'
        ]
        
        if any(keyword in lower_text for keyword in nutrition_keywords):
            return {
                'intent': 'nutrition',
                'is_emergency': False
            }
        
        # Check for exercise questions
        exercise_keywords = [
            'exercise', 'workout', 'fitness', 'physical activity',
            'running', 'walking', 'swimming', 'cycling', 'yoga',
            'strength training', 'cardio', 'stretch', 'flexibility',
            'endurance', 'recovery', 'rest', 'active', 'sedentary'
        ]
        
        if any(keyword in lower_text for keyword in exercise_keywords):
            return {
                'intent': 'exercise',
                'is_emergency': False
            }
        
        # Check for mental health questions
        mental_health_keywords = [
            'mental health', 'depression', 'anxiety', 'stress',
            'panic attack', 'mental illness', 'therapy', 'counseling',
            'psychologist', 'psychiatrist', 'mental', 'emotional',
            'feeling', 'mood', 'sad', 'happy', 'angry', 'frustrated',
            'overwhelmed', 'trauma', 'PTSD', 'bipolar', 'schizophrenia',
            'OCD', 'ADHD', 'autism', 'suicidal', 'self-harm'
        ]
        
        if any(keyword in lower_text for keyword in mental_health_keywords):
            return {
                'intent': 'mental_health',
                'is_emergency': False
            }
        
        # Default to general query if no specific intent detected
        return {
            'intent': 'general_query',
            'is_emergency': False
        }
        # Check for exercise questions
        exercise_keywords = [
            'exercise', 'workout', 'fitness', 'physical activity',
            'running', 'walking', 'swimming', 'cycling', 'yoga',
            'strength training', 'cardio', 'stretch', 'flexibility',
            'endurance', 'recovery', 'rest', 'active', 'sedentary'
        ]
        
        if any(keyword in lower_text for keyword in exercise_keywords):
            return {
                'intent': 'exercise',
                'is_emergency': False
            }
        
        # Check for mental health questions
        mental_health_keywords = [
            'mental health', 'depression', 'anxiety', 'stress',
            'panic attack', 'mental illness', 'therapy', 'counseling',
            'psychologist', 'psychiatrist', 'mental', 'emotional',
            'feeling', 'mood', 'sad', 'happy', 'angry', 'frustrated',
            'overwhelmed', 'trauma', 'PTSD', 'bipolar', 'schizophrenia',
            'OCD', 'ADHD', 'autism', 'suicidal', 'self-harm'
        ]
        
        if any(keyword in lower_text for keyword in mental_health_keywords):
            return {
                'intent': 'mental_health',
                'is_emergency': False
            }
        
        # Default to general query if no specific intent detected
        return {
            'intent': 'general_query',
            'is_emergency': False
        }

    def handle_emergency(self, analysis):
        """Handle emergency situations"""
        emergency_instructions = (
            "üö® EMERGENCY ALERT üö®\n"
            "Based on your message, this appears to be a medical emergency.\n\n"
            "1. Call emergency services immediately (911 or local emergency number)\n"
            "2. If you're with someone, have them stay with you\n"
            "3. Don't try to drive yourself to the hospital\n"
            "4. If you're alone, unlock your door for emergency responders\n\n"
            "I've alerted your emergency contacts if you have them set up."
        )
        
        # Try to notify emergency contacts if user is logged in
        if self.logged_in and self.current_user_id:
            try:
                user_doc = self.users_col.find_one({"_id": ObjectId(self.current_user_id)})
                contacts = user_doc.get("emergency_contacts", [])
                for contact in contacts:
                    logging.info(f"Notified emergency contact: {contact.get('name')} ({contact.get('phone')})")
            except Exception as e:
                logging.error(f"Failed to notify emergency contacts: {str(e)}")
        
        return emergency_instructions

    def handle_medication_advice(self, analysis):
        """Provide advice about taking specific medications for symptoms"""
        medication = analysis.get('medication', '').lower()
        symptom = analysis.get('symptom', '').lower()
        
        # Check if the symptom is in our knowledge base
        symptom_info = None
        for known_symptom, info in self.medical_knowledge.items():
            if known_symptom in symptom:
                symptom_info = info
                break
        
        if not symptom_info:
            return f"I'm not sure about using {medication} for {symptom}. It's best to consult a doctor for proper medical advice."
        
        # Check if the medication is recommended for this symptom
        recommended_meds = [m.lower() for m in symptom_info.get('medicines', [])]
        medication_match = any(med in medication for med in recommended_meds) or any(med in med.lower() for med in recommended_meds)
        
        if medication_match:
            return (
                f"Yes, {medication} can be used for {symptom}.\n"
                f"Recommendations:\n"
                f"- {symptom_info['description']}\n"
                f"- Suggested treatments: {', '.join(symptom_info['suggestions'])}\n"
                "Always follow dosage instructions and consult a doctor if symptoms persist."
            )
        else:
            return (
                f"{medication} is not typically recommended for {symptom}.\n"
                f"For {symptom}, consider these options instead:\n"
                f"- {', '.join(symptom_info['medicines'])}\n"
                "Always consult a doctor or pharmacist before taking any medication."
            )

    def handle_symptom(self, analysis):
        """Provide information about symptoms"""
        symptoms = analysis.get('symptoms', [])
        responses = []
        
        for symptom in symptoms:
            if symptom in self.medical_knowledge:
                info = self.medical_knowledge[symptom]
                response = (
                    f"Information about {symptom}:\n"
                    f"- Description: {info['description']}\n"
                    f"- Suggestions: {', '.join(info['suggestions'])}\n"
                    f"- Medications: {', '.join(info['medicines'])}\n"
                )
                if info['emergency']:
                    response += "‚ö† This could be serious. Seek medical attention if severe.\n"
                responses.append(response)
            else:
                responses.append(
                    f"I don't have specific information about {symptom}. "
                    "It's best to consult a healthcare professional for proper evaluation."
                )
        
        return "\n".join(responses)

    def handle_medication(self, analysis):
        """Provide information about medications"""
        # In a full implementation, this would query a medication database
        return (
            "For accurate medication information:\n"
            "1. Always consult with a doctor or pharmacist\n"
            "2. Read the medication guide provided with your prescription\n"
            "3. Be aware of potential side effects and interactions\n"
            "4. Never share prescription medications with others\n\n"
            "You can ask me about specific medications (e.g., 'What is ibuprofen used for?')"
        )

    def handle_appointment(self):
        """Provide guidance on scheduling appointments"""
        return (
            "To schedule a medical appointment:\n"
            "1. Contact your healthcare provider's office\n"
            "2. Have your insurance information ready\n"
            "3. Be prepared to describe your symptoms\n"
            "4. Ask about telehealth options if available\n\n"
            "For urgent but non-emergency issues, consider urgent care clinics."
        )

    def handle_general_health(self, analysis):
        """Provide general health information"""
        return (
            "General health tips:\n"
            "1. Get regular check-ups and screenings\n"
            "2. Maintain a balanced diet and stay hydrated\n"
            "3. Exercise regularly (150 minutes/week recommended)\n"
            "4. Get 7-9 hours of sleep nightly\n"
            "5. Manage stress through relaxation techniques\n"
            "6. Avoid smoking and limit alcohol consumption\n"
            "7. Practice good hygiene and hand washing\n\n"
            "You can ask me about specific health topics for more information."
        )

    def handle_nutrition(self, analysis):
        """Provide nutrition advice"""
        return (
            "Nutrition recommendations:\n"
            "1. Eat a variety of fruits and vegetables (5+ servings/day)\n"
            "2. Choose whole grains over refined grains\n"
            "3. Include lean proteins (fish, poultry, beans, nuts)\n"
            "4. Limit added sugars and saturated fats\n"
            "5. Watch portion sizes\n"
            "6. Stay hydrated with water (about 8 cups/day)\n"
            "7. Limit processed foods and sodium intake\n\n"
            "Specific dietary needs may vary - consult a nutritionist for personalized advice."
        )

    def handle_exercise(self, analysis):
        """Provide exercise recommendations"""
        return (
            "Exercise guidelines:\n"
            "1. Aim for 150 minutes of moderate activity or 75 minutes of vigorous activity weekly\n"
            "2. Include strength training 2+ days/week\n"
            "3. Incorporate flexibility and balance exercises\n"
            "4. Start slowly if you're new to exercise\n"
            "5. Choose activities you enjoy to stay motivated\n"
            "6. Listen to your body and rest when needed\n"
            "7. Stay hydrated and use proper equipment\n\n"
            "Always consult a doctor before starting a new exercise program, especially if you have health concerns."
        )

    def handle_mental_health(self, analysis):
        """Provide mental health information and resources"""
        return (
            "Mental health is just as important as physical health. Here are some resources:\n"
            "1. Talk to a trusted friend or family member\n"
            "2. Consider professional counseling or therapy\n"
            "3. Practice stress-reduction techniques (meditation, deep breathing)\n"
            "4. Maintain a regular sleep schedule\n"
            "5. Stay connected with supportive people\n"
            "6. Limit alcohol and avoid drugs\n"
            "7. Get regular physical activity\n\n"
            "If you're in crisis or having suicidal thoughts, please call the National Suicide Prevention Lifeline at 1-800-273-8255 or your local emergency number immediately."
        )

    def handle_general_query(self, query):
        """Handle general queries that don't fit specific categories"""
        return (
            "I'm not entirely sure how to respond to that. As a health assistant, I can help with:\n"
            "- Symptom information\n"
            "- Medication questions\n"
            "- General health advice\n"
            "- Nutrition and exercise guidance\n"
            "- Mental health resources\n\n"
            "Could you please rephrase your question or ask about a specific health topic?"
        )

    def start_voice_input(self):
        """Start voice input using microphone with visual feedback"""
        # Disable input while listening
        self.user_input.config(state='disabled')
        
        # Change button color to indicate listening
        voice_button = self.voice_button
        original_bg = voice_button.cget('bg')
        voice_button.config(bg='#e74c3c')  # Red to indicate recording
        
        # Add listening indicator message
        self.add_message("System", "üé§ Listening... Speak now", tag='system', speak=False)
        
        def recognize_thread():
            try:
                with sr.Microphone() as source:
                    # Show adjusting message
                    self.root.after(0, lambda: self.add_message(
                        "System", 
                        "Adjusting for background noise...", 
                        tag='system', 
                        speak=False
                    ))
                    
                    # Adjust for ambient noise
                    self.voice_recognizer.adjust_for_ambient_noise(source, duration=1)
                    
                    # Show ready message
                    self.root.after(0, lambda: self.add_message(
                        "System", 
                        "Ready! Listening for up to 5 seconds...", 
                        tag='system', 
                        speak=False
                    ))
                    
                    # Listen for audio
                    audio = self.voice_recognizer.listen(source, timeout=5, phrase_time_limit=5)
                    
                    # Show processing message
                    self.root.after(0, lambda: self.add_message(
                        "System", 
                        "Processing your speech...", 
                        tag='system', 
                        speak=False
                    ))
                    
                    # Use Google's speech recognition
                    text = self.voice_recognizer.recognize_google(audio)
                    
                    # Process the recognized text
                    self.root.after(0, lambda: self.process_voice_input(text))
                    
            except sr.WaitTimeoutError:
                self.root.after(0, lambda: self.add_message(
                    "System",
                    "Voice input timed out. Please try again.",
                    tag='warning',
                    speak=False
                ))
            except sr.UnknownValueError:
                self.root.after(0, lambda: self.add_message(
                    "System",
                    "Could not understand audio. Please try again or type your message.",
                    tag='warning',
                    speak=False
                ))
            except Exception as e:
                # Capture the error message before passing to lambda
                error_message = str(e)
                logging.error(f"Voice recognition failed: {error_message}")
                
                # Use the captured message in the lambda
                self.root.after(0, lambda: self.add_message(
                    "System",
                    f"Error in voice recognition: {error_message}. Please try typing instead.",
                    tag='warning',
                    speak=False
                ))
            finally:
                # Re-enable input and reset button color
                self.root.after(0, lambda: self.user_input.config(state='normal'))
                self.root.after(0, lambda: voice_button.config(bg=original_bg))
        
        # Start recognition in a separate thread
        threading.Thread(target=recognize_thread, daemon=True).start()

    def process_voice_input(self, text):
        """Process recognized voice input"""
        if not text:
            self.add_message("System", "No speech detected. Please try again.", tag='warning', speak=False)
            return
        
        # Show the recognized text
        self.add_message("System", f"Recognized: \"{text}\"", tag='system', speak=False)
        
        # Insert recognized text into input field
        self.user_input.delete(0, tk.END)
        self.user_input.insert(0, text)
        
        # Process the input
        self.process_input()

    def speak(self, text):
        """Speak text using text-to-speech"""
        try:
            self.tts_engine.say(text)
            self.tts_engine.runAndWait()
        except Exception as e:
            logging.error(f"Text-to-speech failed: {str(e)}")

    def show_auth_dialog(self, mode='login'):
        """Show authentication dialog (login or signup)"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Login" if mode == 'login' else "Sign Up")
        dialog.geometry("400x400")  # Increased height
        dialog.resizable(False, False)
        dialog.configure(bg=self.colors['bg_light'])
        dialog.grab_set()
        
        # Header
        header_frame = tk.Frame(dialog, bg=self.colors['bg_dark'], height=60)
        header_frame.pack(fill='x')
        header_frame.pack_propagate(False)
        
        tk.Label(
            header_frame,
            text="Login" if mode == 'login' else "Create Account",
            font=('Arial', 16),
            bg=self.colors['bg_dark'],
            fg=self.colors['text_light']
        ).pack(side='left', padx=20, pady=10)
        
        # Main content frame
        main_frame = tk.Frame(dialog, bg=self.colors['bg_light'])
        main_frame.pack(fill='both', expand=True, padx=30, pady=20)
        
        # Username field
        tk.Label(
            main_frame,
            text="Username",
            font=('Arial', 11),
            bg=self.colors['bg_light'],
            fg=self.colors['text_dark'],
            anchor='w'
        ).pack(fill='x', pady=(10, 5))
        
        username_entry = tk.Entry(
            main_frame,
            font=('Arial', 11),
            bd=1
        )
        username_entry.pack(fill='x', pady=(0, 15))
        
        # Password field
        tk.Label(
            main_frame,
            text="Password",
            font=('Arial', 11),
            bg=self.colors['bg_light'],
            fg=self.colors['text_dark'],
            anchor='w'
        ).pack(fill='x', pady=(0, 5))
        
        password_entry = tk.Entry(
            main_frame,
            font=('Arial', 11),
            bd=1,
            show="‚Ä¢"
        )
        password_entry.pack(fill='x', pady=(0, 15))
        
        # Email field (for signup only)
        if mode == 'signup':
            tk.Label(
                main_frame,
                text="Email",
                font=('Arial', 11),
                bg=self.colors['bg_light'],
                fg=self.colors['text_dark'],
                anchor='w'
            ).pack(fill='x', pady=(0, 5))
            
            email_entry = tk.Entry(
                main_frame,
                font=('Arial', 11),
                bd=1
            )
            email_entry.pack(fill='x', pady=(0, 15))
        
        # Error message label
        error_label = tk.Label(
            main_frame,
            text="",
            fg=self.colors['error'],
            bg=self.colors['bg_light'],
            font=('Arial', 10),
            wraplength=340,
            justify='center'
        )
        error_label.pack(pady=5)
        
        # Submit function
        def submit():
            username = username_entry.get().strip()
            password = password_entry.get().strip()
            
            if not username or not password:
                error_label.config(text="Username and password are required")
                return
            
            if mode == 'signup':
                email = email_entry.get().strip()
                if not email or '@' not in email:
                    error_label.config(text="Valid email is required")
                    return
                
                success, message = self.signup_user(username, email, password)
                if success:
                    dialog.destroy()
                    self.add_message(
                        "System",
                        f"Account created successfully! Welcome {username}",
                        tag='system'
                    )
                else:
                    error_label.config(text=message)
            else:
                success, message = self.login_user(username, password)
                if success:
                    dialog.destroy()
                    self.add_message(
                        "System",
                        f"Login successful! Welcome back {username}",
                        tag='system'
                    )
                else:
                    error_label.config(text=message)
        
        # Create a prominent blue submit button
        submit_button = tk.Button(
            main_frame,
            text="SUBMIT",
            command=submit,
            bg="#3498db",  # Bright blue
            fg="white",
            font=('Arial', 14, 'bold'),
            padx=20,
            pady=10,
            relief=tk.RAISED,
            bd=3,
            activebackground="#2980b9",  # Darker blue on hover
            activeforeground="white",
            cursor="hand2"
        )
        submit_button.pack(fill='x', pady=20)
        
        # Separator
        separator = tk.Frame(main_frame, height=2, bg=self.colors['divider'])
        separator.pack(fill='x', pady=10)
        
        # Switch between login and signup
        switch_text = "Need an account? Sign up" if mode == 'login' else "Already have an account? Login"
        switch_mode = 'signup' if mode == 'login' else 'login'
        
        switch_button = tk.Button(
            main_frame,
            text=switch_text,
            command=lambda: [dialog.destroy(), self.show_auth_dialog(switch_mode)],
            font=('Arial', 11, 'underline'),
            fg="#2980b9",
            bg=self.colors['bg_light'],
            bd=0,
            activeforeground="#1a5276",
            activebackground=self.colors['bg_light'],
            cursor="hand2"
        )
        switch_button.pack(pady=5)

    def hash_password(self, password, salt=None):
        """Hash password with salt using PBKDF2"""
        if not salt:
            salt = os.urandom(16)
        else:
            salt = base64.b64decode(salt)
        
        key = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt,
            100000
        )
        
        return base64.b64encode(key).decode('utf-8'), base64.b64encode(salt).decode('utf-8')

    def signup_user(self, username, email, password):
        """Register a new user in MongoDB"""
        try:
            if self.users_col.find_one({"$or": [{"username": username}, {"email": email}]}):
                return False, "Username or email already exists"
            password_hash, salt = self.hash_password(password)
            user_doc = {
                "username": username,
                "email": email,
                "password_hash": password_hash,
                "salt": salt,
                "created_at": datetime.now(),
                "last_login": None,
                "emergency_contacts": []
            }
            result = self.users_col.insert_one(user_doc)
            self.logged_in = True
            self.current_user_id = str(result.inserted_id)
            self.current_username = username
            
            # Update UI to show logged-in state
            self.user_label.config(text=username)
            self.login_button.pack_forget()  # Hide login button
            self.signup_button.pack_forget()  # Hide signup button
            
            # Add logout button
            self.logout_button = tk.Button(
                self.user_status_frame,
                text="Logout",
                command=self.logout_user,
                bg=self.colors['warning'],
                fg=self.colors['text_light'],
                font=('Arial', 11),
                padx=15,
                relief=tk.FLAT,
                activebackground='#d35400',  # Darker orange on hover
                activeforeground=self.colors['text_light']
            )
            self.logout_button.pack(side='left', before=self.user_label)
            
            return True, "Signup successful"
        except Exception as e:
            logging.error(f"Signup failed: {str(e)}")
            return False, "Database error during signup"

    def login_user(self, username, password):
        """Authenticate existing user in MongoDB"""
        try:
            user_doc = self.users_col.find_one({"username": username})
            if not user_doc:
                return False, "Invalid username or password"
            input_hash, _ = self.hash_password(password, user_doc["salt"])
            if input_hash != user_doc["password_hash"]:
                return False, "Invalid username or password"
            self.logged_in = True
            self.current_user_id = str(user_doc["_id"])
            self.current_username = user_doc["username"]
            
            # Update UI to show logged-in state
            self.user_label.config(text=user_doc["username"])
            self.login_button.pack_forget()  # Hide login button
            self.signup_button.pack_forget()  # Hide signup button
            
            # Add logout button
            self.logout_button = tk.Button(
                self.user_status_frame,
                text="Logout",
                command=self.logout_user,
                bg=self.colors['warning'],
                fg=self.colors['text_light'],
                font=('Arial', 11),
                padx=15,
                relief=tk.FLAT,
                activebackground='#d35400',  # Darker orange on hover
                activeforeground=self.colors['text_light']
            )
            self.logout_button.pack(side='left', before=self.user_label)
            
            # Update database with login time
            self.users_col.update_one(
                {"_id": user_doc["_id"]},
                {"$set": {"last_login": datetime.now()}}
            )
            return True, "Login successful"
        except Exception as e:
            logging.error(f"Login failed: {str(e)}")
            return False, "Database error during login"

    def logout_user(self):
        """Log out the current user"""
        self.logged_in = False
        self.current_user_id = None
        self.current_username = None
        
        # Update UI to show logged-out state
        self.user_label.config(text="Guest")
        
        # Remove logout button
        if hasattr(self, 'logout_button'):
            self.logout_button.pack_forget()
        
        # Show login and signup buttons again
        self.login_button.pack(side='left', padx=(0, 5))
        self.signup_button.pack(side='left')
        
        self.add_message("System", "You have been logged out", tag='system')

    def cleanup(self):
        """Clean up resources before closing"""
        if hasattr(self, 'tts_engine'):
            self.tts_engine.stop()
        if hasattr(self, 'mongo_client'):
            self.mongo_client.close()

    def initialize_database(self):
        """Initialize MongoDB connection with robust error handling"""
        try:
            # Connection parameters - update these as needed
            mongo_host = "localhost"
            mongo_port = 27017
            mongo_db_name = "medai_pro"
            connection_string = f"mongodb://{mongo_host}:{mongo_port}/"
            
            logging.info(f"Attempting to connect to MongoDB at {connection_string}")
            
            # Try to connect to MongoDB with timeout
            self.mongo_client = MongoClient(
                connection_string,
                serverSelectionTimeoutMS=5000,  # 5 second timeout
                connectTimeoutMS=5000,
                socketTimeoutMS=5000
            )
            
            # Test the connection by requesting server info
            server_info = self.mongo_client.server_info()
            logging.info(f"Connected to MongoDB version: {server_info.get('version', 'unknown')}")
            
            # Set up database and collections
            self.db = self.mongo_client[mongo_db_name]
            self.users_col = self.db["users"]
            self.conversations_col = self.db["conversations"]
            
            # Create indexes for better performance if they don't exist
            self.users_col.create_index([("username", 1)], unique=True)
            self.users_col.create_index([("email", 1)], unique=True)
            self.conversations_col.create_index([("user_id", 1), ("timestamp", 1)])
            
            logging.info("MongoDB connection established successfully")
            return True
            
        except Exception as e:
            error_msg = f"MongoDB connection failed: {str(e)}"
            logging.error(error_msg)
            print(f"Database connection error: {error_msg}")
            
            # Create dummy collections that won't crash the app
            self.mongo_client = None
            self.db = None
            
            # Define a DummyCollection class for offline operation
            class DummyCollection:
                def __init__(self, name):
                    self.name = name
                
                def find_one(self, *args, **kwargs):
                    logging.debug(f"Dummy find_one called on {self.name}")
                    return None
                
                def find(self, *args, **kwargs):
                    logging.debug(f"Dummy find called on {self.name}")
                    return []
                
                def insert_one(self, *args, **kwargs):
                    logging.debug(f"Dummy insert_one called on {self.name}")
                    return type('obj', (object,), {'inserted_id': None})
                
                def update_one(self, *args, **kwargs):
                    logging.debug(f"Dummy update_one called on {self.name}")
                    return
                
                def create_index(self, *args, **kwargs):
                    logging.debug(f"Dummy create_index called on {self.name}")
                    return
                
                def list_indexes(self, *args, **kwargs):
                    logging.debug(f"Dummy list_indexes called on {self.name}")
                    return []
            
            self.users_col = DummyCollection("users")
            self.conversations_col = DummyCollection("conversations")
            return False

    def show_database_status(self):
        """Show database connection status after UI is created"""
        if hasattr(self, 'mongo_client') and self.mongo_client:
            self.add_message(
                "System", 
                "Database connected successfully", 
                tag='system', 
                speak=False
            )
        else:
            self.add_message(
                "System", 
                "Database connection failed. Some features may not be available.", 
                tag='warning', 
                speak=False
            )

if __name__ == "__main__":
    root = tk.Tk()
    app = HealthAssistant(root)
    
    def on_closing():
        app.cleanup()
        root.destroy()
    
    root.protocol("WM_DELETE_WINDOW", on_closing)
    root.mainloop()
